// Generated by CoffeeScript 1.7.1
var Graph, Record, User, app, bodyParser, clientIdsByServerId, clientsIdsForUserId, connection, count, express, getUpdateServer, graph, graphDef, groupClientIdsByPort, mysql, name, parse, portForClient, portServer, portServers, r, rel, rels, request, serverId, start, table, userIdForClientId, userIdsByClientId, _, _base, _base1, _base2, _i, _j, _len, _len1,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

mysql = require('mysql');

_ = require('lodash');

express = require('express');

bodyParser = require('body-parser');

request = require('request');

graph = require('./graph');

Graph = {
  rels: {},
  root: {},
  inGraph: {},
  fields: {
    root_elements: {
      element_type: 'value'
    },
    bundle_elements: {
      element_type: 'value'
    },
    list_elements: {
      element_type: 'value'
    }
  },
  inGraph: function(table) {
    var _ref;
    return (_ref = this.inGraph[table]) != null ? _ref : this.rels[table];
  },
  children: function(db, table, record) {
    var contained, containedRecord, containedTable, records, rel, _i, _j, _len, _len1, _ref, _ref1;
    contained = [];
    _ref = this.rels[table];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rel = _ref[_i];
      if (rel.owns) {
        if (!rel.foreignKey) {
          containedTable = _.isFunction(rel.table) ? rel.table(record) : rel.table;
          containedRecord = (_ref1 = db[containedTable]) != null ? _ref1[record[rel.field]] : void 0;
          if (containedRecord) {
            if (_.isFunction(rel.owns)) {
              if (rel.owns(containedRecord)) {
                contained.push({
                  table: containedTable,
                  record: containedRecord
                });
              }
            } else {
              contained.push({
                table: containedTable,
                record: containedRecord
              });
            }
          }
        } else {
          records = _.filter(db[rel.table], function(r) {
            return r[rel.field] === record.id;
          });
          for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
            record = records[_j];
            contained.push({
              table: rel.table,
              record: record
            });
          }
        }
      }
    }
    return contained;
  },
  contained: function(db, table, record) {
    var contained, containedRecord, containedTable, records, rel, _i, _j, _len, _len1, _ref, _ref1;
    contained = [];
    _ref = this.rels[table];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rel = _ref[_i];
      if (rel.owns) {
        if (!rel.foreignKey) {
          containedTable = _.isFunction(rel.table) ? rel.table(record) : rel.table;
          containedRecord = (_ref1 = db[containedTable]) != null ? _ref1[record[rel.field]] : void 0;
          if (containedRecord) {
            if (_.isFunction(rel.owns)) {
              if (rel.owns(containedRecord)) {
                contained.push({
                  table: containedTable,
                  record: containedRecord
                });
                contained = contained.concat(this.contained(db, containedTable, containedRecord));
              }
            } else {
              contained.push({
                table: containedTable,
                record: containedRecord
              });
              contained = contained.concat(this.contained(db, containedTable, containedRecord));
            }
          }
        } else {
          records = _.filter(db[rel.table], function(r) {
            return r[rel.field] === record.id;
          });
          for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
            record = records[_j];
            contained.push({
              table: rel.table,
              record: record
            });
            contained = contained.concat(this.contained(db, rel.table, record));
          }
        }
      }
    }
    return contained;
  },
  owner: function(db, table, record) {
    var ownerRecord, records, rel, _i, _len, _ref;
    if (this.root[table]) {
      return null;
    } else if (this.rels[table]) {
      _ref = this.rels[table];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rel = _ref[_i];
        if (rel.owner) {
          if (!rel.foreignKey) {
            table = _.isFunction(rel.table) ? rel.table(this) : rel.table;
            if (!db[table]) {
              console.log(table);
            }
            ownerRecord = db[table][record[rel.field]];
            if (ownerRecord) {
              return {
                table: table,
                record: ownerRecord
              };
            }
          } else {
            if (rel.filter) {
              records = _.filter(db[rel.table], function(r) {
                return r[rel.field] === record.id && rel.filter(table, record, r);
              });
            } else {
              records = _.filter(db[rel.table], function(r) {
                return r[rel.field] === record.id;
              });
            }
            if (records[0]) {
              return {
                table: rel.table,
                record: records[0]
              };
            }
          }
        }
      }
    }
  }
};

Graph.fieldRel = {};

for (table in graph) {
  graphDef = graph[table];
  Graph.rels[table] = rels = [];
  for (name in graphDef) {
    rel = graphDef[name];
    if (name === 'root') {
      Graph.root[table] = rel;
    } else if (name === 'inGraph') {
      Graph.inGraph[table] = rel;
    } else {
      if (!_.isArray(rel)) {
        rel = [rel];
      }
      for (_i = 0, _len = rel.length; _i < _len; _i++) {
        r = rel[_i];
        if (r.table) {
          if ((_base = Graph.fieldRel)[table] == null) {
            _base[table] = {};
          }
          Graph.fieldRel[table][name] = r;
          if (!_.isFunction(r.table)) {
            if ((_base1 = Graph.fields)[table] == null) {
              _base1[table] = {};
            }
            Graph.fields[table][name] = 'id';
          }
          rels.push({
            table: r.table,
            owns: r.owns,
            owner: r.owner,
            field: name,
            filter: r.filter
          });
        } else if (r.field) {
          if ((_base2 = Graph.fields)[name] == null) {
            _base2[name] = {};
          }
          Graph.fields[name][r.field] = 'id';
          rels.push({
            foreignKey: true,
            field: r.field,
            table: name,
            owns: r.owns,
            owner: r.owner,
            filter: r.filter
          });
        }
      }
    }
  }
}

Record = (function() {
  function Record(table, fields) {
    this.table = table;
    this.fields = fields;
  }

  Record.prototype.forEachRelationship = function(cb) {
    var count, record, records, tick, _fn, _j, _len1;
    table = this.table;
    record = this.fields;
    rels = Graph.rels[table];
    records = [];
    if (rels.length) {
      count = 0;
      tick = function() {
        if (!--count) {
          return cb();
        }
      };
      _fn = (function(_this) {
        return function(rel) {
          var owns;
          if (rel.owns) {
            owns = _.isFunction(rel.owns) ? rel.owns(_this.fields) : rel.owns;
            if (owns) {
              ++count;
              if (rel.foreignKey) {
                table = rel.table;
                return (function(table) {
                  return connection.query("SELECT * FROM m_" + table + " WHERE " + rel.field + " = " + record.id, function(err, rows, fields) {
                    var row, _k, _len2;
                    for (_k = 0, _len2 = rows.length; _k < _len2; _k++) {
                      row = rows[_k];
                      cb(new Record(table, row));
                    }
                    return tick();
                  });
                })(table);
              } else {
                table = _.isFunction(rel.table) ? rel.table(record) : rel.table;
                return (function(table) {
                  return connection.query("SELECT * FROM m_" + table + " WHERE id = " + record[rel.field], function(err, rows, fields) {
                    cb(new Record(table, rows[0]));
                    return tick();
                  });
                })(table);
              }
            }
          }
        };
      })(this);
      for (_j = 0, _len1 = rels.length; _j < _len1; _j++) {
        rel = rels[_j];
        _fn(rel);
      }
      if (!count) {
        return cb();
      }
    } else {
      return cb();
    }
  };

  Record.prototype.getRelationships = function(cb) {
    var records;
    records = [];
    return this.forEachRelationship(function(record) {
      if (record) {
        return records.push(record);
      } else {
        return cb(records);
      }
    });
  };

  Record.prototype.contained = function(cb) {
    var count, done, records, sent;
    records = [];
    count = 0;
    sent = false;
    done = false;
    return this.forEachRelationship(function(record) {
      if (record) {
        ++count;
        records.push(record);
        return record.contained(function(r) {
          records = records.concat(r);
          --count;
          if (!count && done) {
            sent = true;
            return cb(records);
          }
        });
      } else {
        done = true;
        if (!count && !sent) {
          return cb(records);
        }
      }
    });
  };

  return Record;

})();

clientIdsByServerId = {};

clientsIdsForUserId = {};

userIdsByClientId = {};

userIdForClientId = function(clientId, cb) {
  if (userIdsByClientId[clientId]) {
    return cb(userIdsByClientId[clientId]);
  } else {
    return connection.query("SELECT user_id FROM clients WHERE client_id = '" + clientId + "'", function(error, rows, fields) {
      return cb(userIdsByClientId[clientId] = parseInt(rows[0].user_id));
    });
  }
};

parse = function(json) {
  var e;
  try {
    return JSON.parse(json);
  } catch (_error) {
    e = _error;
    console.log(json);
    throw e;
  }
};

User = (function() {
  User.users = {};

  User.user = function(userId) {
    var _base3;
    return (_base3 = this.users)[userId] != null ? _base3[userId] : _base3[userId] = new User(userId);
  };

  User.operate = function(userId, cb) {
    var user;
    user = this.user(userId);
    return user.operate(function() {
      return cb(user);
    });
  };

  User.clientSubscriptions = {};

  function User(id) {
    this.id = parseInt(id);
  }

  User.prototype.operate = function(cb) {
    if (this.operating) {
      if (this.queue == null) {
        this.queue = [];
      }
      return this.queue.push(cb);
    } else {
      this.operating = true;
      return cb();
    }
  };

  User.prototype.done = function() {
    var func;
    this.operating = false;
    if (this.queue) {
      func = this.queue.shift();
      if (!this.queue.length) {
        delete this.queue;
      }
      return func();
    }
  };

  User.prototype.sendUpdate = function(changes, object) {
    var clientIds, grouped, port, subscribers, _ref, _results;
    subscribers = (_ref = this.subscribers) != null ? _ref[object] : void 0;
    if (subscribers) {
      grouped = groupClientIdsByPort(subscribers);
      if (_.isObject(changes)) {
        changes = JSON.stringify(changes);
      }
      _results = [];
      for (port in grouped) {
        clientIds = grouped[port];
        _results.push(request({
          url: "http://" + port + "/update",
          method: 'post',
          form: {
            clientIds: clientIds,
            userId: this.id,
            changes: changes
          }
        }));
      }
      return _results;
    }
  };

  User.prototype.update = function(clientId, updateToken, changes, cb) {
    return this.initOutline((function(_this) {
      return function() {
        return request({
          url: "http://" + (getUpdateServer()) + "/update.php?clientId=" + clientId + "&userId=" + _this.id,
          method: 'post',
          form: {
            updateToken: updateToken,
            changes: changes
          }
        }, function(error, response, body) {
          var add, addChangesForSubscribers, broadcast, changesForSubscribers, child, children, contained, count, e, field, fields, id, ids, newId, recordChanges, relTable, t, tableChanges, toDelete, value, __, _base3, _j, _k, _len1, _len2, _name, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
          if (body === 'invalid update token') {

          } else if (body === 'invalid client id') {

          } else {
            try {
              body = parse(body);
            } catch (_error) {
              e = _error;
              console.log(body);
              throw e;
            }
            if (body.status === 'ok') {
              if (_this.subscribers) {
                delete body.changes.products;
                delete body.changes.product_variants;
                changesForSubscribers = {};
                if (_this.subscribers['*']) {
                  changesForSubscribers['*'] = body.changes;
                }
                if (_this.subscribers['/']) {
                  changesForSubscribers['/'] = body.changes;
                }
                if (_this.subscribers['@'] && ((_ref = body.changes) != null ? (_ref1 = _ref.users) != null ? _ref1["G" + _this.id] : void 0 : void 0)) {
                  id = "G" + _this.id;
                  changes = {
                    users: {}
                  };
                  changes.users[id] = body.changes.users[id];
                  changesForSubscribers['@'] = changes;
                }
                broadcast = function() {
                  var clientIds, grouped, object, port, subscribers;
                  for (object in changesForSubscribers) {
                    changes = changesForSubscribers[object];
                    subscribers = _.without(_this.subscribers[object], clientId);
                    if (subscribers.length) {
                      grouped = groupClientIdsByPort(subscribers);
                      changes = JSON.stringify(body.changes);
                      for (port in grouped) {
                        clientIds = grouped[port];
                        request({
                          url: "http://" + port + "/update",
                          method: 'post',
                          form: {
                            clientIds: clientIds,
                            userId: _this.id,
                            changes: changes
                          }
                        });
                      }
                    }
                  }
                  return cb(JSON.stringify({
                    status: 'ok',
                    updateToken: body.updateToken,
                    mapping: body.mapping
                  }));
                };
                if (_this.outline) {
                  addChangesForSubscribers = function(object, table, id, changes) {
                    var _base3;
                    if (_this.subscribers[object]) {
                      if (changesForSubscribers[object] == null) {
                        changesForSubscribers[object] = {};
                      }
                      if ((_base3 = changesForSubscribers[object])[table] == null) {
                        _base3[table] = {};
                      }
                      if (!changesForSubscribers[object][table][id]) {
                        return changesForSubscribers[object][table][id] = changes;
                      } else {
                        return _.extend(changesForSubscribers[object][table][id], changes);
                      }
                    }
                  };
                  add = function(table, id, changes) {
                    var _results;
                    r = table === 'activity' ? Graph.owner(_this.outline, table, changes) : {
                      table: table,
                      record: _this.outline[table][id]
                    };
                    _results = [];
                    while (r) {
                      addChangesForSubscribers("" + r.table + "." + r.record.id, table, 'G' + id, changes);
                      _results.push(r = Graph.owner(_this.outline, r.table, r.record));
                    }
                    return _results;
                  };
                  _ref2 = body.changes;
                  for (table in _ref2) {
                    tableChanges = _ref2[table];
                    if (Graph.inGraph(table)) {
                      for (id in tableChanges) {
                        recordChanges = tableChanges[id];
                        if (recordChanges !== 'deleted') {
                          id = parseInt(id.substr(1));
                          _this.addToOutline(table, id, recordChanges);
                        }
                      }
                    }
                  }
                  _ref3 = body.changes;
                  for (table in _ref3) {
                    tableChanges = _ref3[table];
                    if (Graph.inGraph(table)) {
                      for (id in tableChanges) {
                        recordChanges = tableChanges[id];
                        add(table, parseInt(id.substr(1)), recordChanges);
                      }
                    }
                  }
                  count = 0;
                  toDelete = {};
                  _ref4 = body.changes;
                  for (table in _ref4) {
                    tableChanges = _ref4[table];
                    if (Graph.inGraph(table)) {
                      if ((_base3 = _this.outline)[table] == null) {
                        _base3[table] = {};
                      }
                      for (id in tableChanges) {
                        recordChanges = tableChanges[id];
                        id = parseInt(id.substr(1));
                        if (recordChanges === 'deleted') {
                          children = Graph.children(_this.outline, table, _this.outline[table][id]);
                          for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
                            child = children[_j];
                            if (toDelete[_name = child.table] == null) {
                              toDelete[_name] = {};
                            }
                            toDelete[child.table][child.record.id] = true;
                          }
                          delete _this.outline[table][id];
                        } else {
                          fields = Graph.fields[table];
                          if (fields) {
                            for (field in fields) {
                              if (Graph.fields[table][field] === 'id' && (value = recordChanges[field])) {
                                newId = parseInt(value.substr(1));
                                if (r = (_ref5 = Graph.fieldRel) != null ? (_ref6 = _ref5[table]) != null ? _ref6[field] : void 0 : void 0) {
                                  t = r.table;
                                  relTable = _.isFunction(t) ? t(_this.outline[table][id]) : t;
                                  if (Graph.inGraph(relTable)) {
                                    if (!((_ref7 = _this.outline[relTable]) != null ? _ref7[newId] : void 0)) {
                                      ++count;
                                      (function(table, id) {
                                        return _this.data("" + relTable + "." + newId, (function(data) {
                                          var dataId, dataRecord, dataRecords, dataTable;
                                          try {
                                            data = parse(data);
                                          } catch (_error) {
                                            e = _error;
                                            console.log(data);
                                            throw e;
                                          }
                                          for (dataTable in data) {
                                            dataRecords = data[dataTable];
                                            for (dataId in dataRecords) {
                                              dataRecord = dataRecords[dataId];
                                              dataId = parseInt(dataId.substr(1));
                                              _this.addToOutline(dataTable, dataId, dataRecord);
                                              add(dataTable, dataId, dataRecord);
                                            }
                                          }
                                          if (!--count) {
                                            return broadcast();
                                          }
                                        }), {
                                          claim: true,
                                          collaborators: false
                                        });
                                      })(table, id);
                                    } else {
                                      if ((_ref8 = toDelete[relTable]) != null ? _ref8[newId] : void 0) {
                                        delete toDelete[relTable][newId];
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      for (table in toDelete) {
                        ids = toDelete[table];
                        for (id in ids) {
                          __ = ids[id];
                          contained = Graph.contained(_this.outline, table, _this.outline[table][id]);
                          for (_k = 0, _len2 = contained.length; _k < _len2; _k++) {
                            r = contained[_k];
                            delete _this.outline[r.table][r.record.id];
                          }
                          delete _this.outline[table][id];
                        }
                      }
                    }
                  }
                  if (!count) {
                    return broadcast();
                  }
                } else {
                  return broadcast();
                }
              } else {
                return cb(JSON.stringify({
                  status: 'ok',
                  updateToken: body.updateToken,
                  mapping: body.mapping
                }));
              }
            } else if (body.status === 'invalidUpdateToken') {
              return cb(JSON.stringify({
                status: 'invalidUpdateToken',
                updateToken: body.updateToken
              }));
            }
          }
        });
      };
    })(this));
  };

  User.prototype.addSubscriber = function(clientId, object) {
    var _base3, _base4, _base5, _name;
    if (!(object === '*' || object === '/' || object === '@')) {
      this.needsOutline = true;
    }
    if (this.subscribers == null) {
      this.subscribers = {};
    }
    if ((_base3 = this.subscribers)[object] == null) {
      _base3[object] = [];
    }
    if (!(__indexOf.call(this.subscribers[object], clientId) >= 0)) {
      this.subscribers[object].push(clientId);
      if ((_base4 = User.clientSubscriptions)[clientId] == null) {
        _base4[clientId] = {};
      }
      if ((_base5 = User.clientSubscriptions[clientId])[_name = this.id] == null) {
        _base5[_name] = [];
      }
      return User.clientSubscriptions[clientId][this.id].push(object);
    }
  };

  User.prototype.removeSubscriber = function(clientId, object) {
    var count, o, size, _j, _len1, _ref, _ref1;
    if (this.subscribers[object]) {
      _.pull(this.subscribers[object], clientId);
      if (!this.subscribers[object].length) {
        delete this.subscribers[object];
        if (_.isEmpty(this.subscribers)) {
          delete this.subscribers;
          delete this.outline;
        } else if (this.outline) {
          size = _.size(this.subscribers);
          if (size <= 3) {
            count = 0;
            _ref = ['*', '/', '@'];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              o = _ref[_j];
              if (this.subscribers[o]) {
                count++;
              }
            }
            if (count === size) {
              delete this.outline;
            }
          }
        }
      }
    }
    if ((_ref1 = User.clientSubscriptions[clientId]) != null ? _ref1[this.id] : void 0) {
      _.pull(User.clientSubscriptions[clientId][this.id], object);
      if (!User.clientSubscriptions[clientId][this.id].length) {
        delete User.clientSubscriptions[clientId][this.id];
        if (_.isEmpty(User.clientSubscriptions[clientId])) {
          return delete User.clientSubscriptions[clientId];
        }
      }
    }
  };

  User.prototype.hasPermissions = function() {
    var action, args, cb, clientId, _j;
    clientId = arguments[0], action = arguments[1], args = 4 <= arguments.length ? __slice.call(arguments, 2, _j = arguments.length - 1) : (_j = 2, []), cb = arguments[_j++];
    if (clientId === 'Carl Sagan') {
      return cb(true);
    } else {
      return userIdForClientId(clientId, (function(_this) {
        return function(userId) {
          var object;
          if (action === 'init') {
            if (userId === _this.id) {
              return cb(true);
            } else {
              return cb(false);
            }
          } else if (action === 'update') {
            if (userId === _this.id) {
              return cb(true);
            } else {
              return _this.initShared(function() {
                return _this.initOutline((function() {
                  var changes, id, object, permitted, recordChanges, tableChanges, _ref, _ref1;
                  changes = args[0];
                  if (_this.shared['/'] && __indexOf.call(_this.shared['/'], userId) >= 0) {
                    for (table in changes) {
                      tableChanges = changes[table];
                      for (id in tableChanges) {
                        recordChanges = tableChanges[id];
                        if (id[0] === 'G' && !((_ref = _this.outline) != null ? (_ref1 = _ref[table]) != null ? _ref1[id.substr(1)] : void 0 : void 0)) {
                          cb(false);
                          return;
                        }
                      }
                    }
                  } else {
                    for (table in changes) {
                      tableChanges = changes[table];
                      for (id in tableChanges) {
                        recordChanges = tableChanges[id];
                        if (id[0] === 'G') {
                          id = id.substr(1);
                          if (_this.outline[table][id]) {
                            r = {
                              table: table,
                              record: _this.outline[table][id]
                            };
                            permitted = false;
                            while (r) {
                              object = "" + r.table + "." + r.record.id;
                              if (_this.shared[object] && (__indexOf.call(_this.shared[object], userId) >= 0)) {
                                permitted = true;
                                break;
                              }
                              r = Graph.owner(_this.outline, r.table, r.record);
                            }
                            if (!permitted) {
                              cb(false);
                              return;
                            }
                          } else {
                            cb(false);
                            return;
                          }
                        }
                      }
                    }
                  }
                  return cb(true);
                }), true);
              });
            }
          } else if (action === 'subscribe') {
            object = args[0];
            if (userId === _this.id) {
              if (object === '*') {
                return cb(true);
              } else {
                return cb(false);
              }
            } else {
              if (object === '@') {
                return connection.query("SELECT 1 FROM shared WHERE user_id = " + userId + " && with_user_id = " + _this.id + " || user_id = " + _this.id + " && with_user_id = " + userId, function(err, rows) {
                  return cb(rows.length);
                });
              } else {
                return _this.initShared(function() {
                  if (_this.shared[object] && (__indexOf.call(_this.shared[object], userId) >= 0)) {
                    return cb(true);
                  } else {
                    return cb(false);
                  }
                });
              }
            }
          }
        };
      })(this));
    }
  };

  User.prototype.initShared = function(cb) {
    if (!this.shared) {
      this.shared = {};
      return connection.query("SELECT * FROM shared WHERE user_id = " + this.id, (function(_this) {
        return function(error, rows, fields) {
          var row, _base3, _j, _len1, _name;
          for (_j = 0, _len1 = rows.length; _j < _len1; _j++) {
            row = rows[_j];
            if ((_base3 = _this.shared)[_name = row.object] == null) {
              _base3[_name] = [];
            }
            _this.shared[row.object].push(row.with_user_id);
          }
          return cb();
        };
      })(this));
    } else {
      return cb();
    }
  };

  User.prototype.data = function(object, cb, opts) {
    if (opts == null) {
      opts = {};
    }
    if (opts.claim == null) {
      opts.claim = false;
    }
    if (opts.collaborators == null) {
      opts.collaborators = true;
    }
    return request({
      url: "http://" + (getUpdateServer()) + "/data.php?userId=" + this.id + "&object=" + object + "&claim=" + (opts.claim ? 1 : 0) + "&collaborators=" + (opts.collaborators ? 1 : 0)
    }, function(err, response, body) {
      return cb(body);
    });
  };

  User.prototype.addToOutline = function(table, id, inValues) {
    var contained, field, type, value, values, _base3, _j, _len1, _ref;
    if (table === 'activity') {
      return;
    }
    values = {};
    _ref = Graph.fields[table];
    for (name in _ref) {
      type = _ref[name];
      if (name in inValues) {
        if (type === 'value') {
          values[name] = inValues[name];
        } else if (type === 'id') {
          if (inValues[name][0] === 'G') {
            values[name] = parseInt(inValues[name].substr(1));
          } else {
            values[name] = parseInt(inValues[name]);
          }
        }
      }
    }
    if ((_base3 = this.outline)[table] == null) {
      _base3[table] = {};
    }
    if (!this.outline[table][id]) {
      values.id = parseInt(id);
      return this.outline[table][id] = values;
    } else {
      for (field in values) {
        value = values[field];
        if (Graph.fields[table][field] === 'id') {
          contained = Graph.contained(this.outline, table, this.outline[table][id]);
          for (_j = 0, _len1 = contained.length; _j < _len1; _j++) {
            r = contained[_j];
            delete this.outline[r.table][r.record.id];
          }
          break;
        }
      }
      return _.extend(this.outline[table][id][field], values);
    }
  };

  User.prototype.addRecord = function(record) {
    return this.addToOutline(record.table, record.fields.id, record.fields);
  };

  User.prototype.initOutline = function(cb, force) {
    if (force == null) {
      force = false;
    }
    if (!this.outline && (this.needsOutline || force)) {
      this.outline = {};
      delete this.needsOutline;
      return connection.query("SELECT * FROM m_root_elements WHERE user_id = " + this.id, (function(_this) {
        return function(err, rows, fields) {
          var count, record, row, _j, _len1, _results;
          if (rows.length) {
            count = rows.length;
            _results = [];
            for (_j = 0, _len1 = rows.length; _j < _len1; _j++) {
              row = rows[_j];
              record = new Record('root_elements', row);
              _this.addRecord(record);
              _results.push(record.contained(function(records) {
                var _k, _len2;
                for (_k = 0, _len2 = records.length; _k < _len2; _k++) {
                  record = records[_k];
                  _this.addRecord(record);
                }
                --count;
                if (!count) {
                  return cb();
                }
              }));
            }
            return _results;
          } else {
            return cb();
          }
        };
      })(this));
    } else {
      return cb();
    }
  };

  return User;

})();

connection = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: '',
  database: 'agora'
});

connection.connect();

app = express();

app.use(bodyParser());

app.listen(3000);

portServers = ['localhost:3001'];

portForClient = function(clientId) {
  return 'localhost:3001';
};

getUpdateServer = function() {
  return 'ext.agora.dev/ext/ws';
};

groupClientIdsByPort = function(clientIds) {
  var clientId, grouped, port, _j, _len1;
  grouped = {};
  for (_j = 0, _len1 = clientIds.length; _j < _len1; _j++) {
    clientId = clientIds[_j];
    port = portForClient(clientId);
    if (grouped[port] == null) {
      grouped[port] = [];
    }
    grouped[port].push(clientId);
  }
  return grouped;
};

app.get('/debug', function(req, res) {
  var user, userId;
  console.log('====DEBUG====');
  userId = req.query.userId;
  user = User.user(userId);
  console.log('=user.subscribers=');
  console.log(user.subscribers);
  console.log('=user.outline=');
  console.log(user.outline);
  console.log('=user.shared=');
  console.log(user.shared);
  console.log('=User.clientSubscriptions=');
  console.log(User.clientSubscriptions);
  console.log('=clientIdsByServerId=');
  console.log(clientIdsByServerId);
  return res.send('');
});

serverId = 1;

start = function() {
  app.post('/port/started', function(req, res) {
    var clientId, clientIds, object, objects, subscriptions, user, userId, __, _j, _len1;
    if (clientIdsByServerId[req.body.serverId]) {
      clientIds = clientIdsByServerId[req.body.serverId];
      for (clientId in clientIds) {
        __ = clientIds[clientId];
        subscriptions = _.cloneDeep(User.clientSubscriptions[clientId]);
        for (userId in subscriptions) {
          objects = subscriptions[userId];
          user = User.user(userId);
          for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
            object = objects[_j];
            user.removeSubscriber(clientId, object);
          }
        }
      }
      delete clientIdsByServerId[req.body.serverId];
    }
    return res.send('ok');
  });
  app.post('/shared', function(req, res) {
    var action, record;
    record = req.body.record;
    action = req.body.action;
    return User.operate(req.body.userId, function(user) {
      var changes, clientId, clientIds, withUserId, _j, _len1, _ref;
      if ((_ref = user.subscribers) != null ? _ref['*'] : void 0) {
        changes = {
          shared_objects: {}
        };
        if (action === 'create') {
          if (user.shared && parseInt(record.user_id) === user.id) {
            if (!user.shared[record.object]) {
              user.shared[record.object] = [];
            }
            user.shared[record.object].push(parseInt(record.with_user_id));
          }
          changes.shared_objects['G' + record.id] = {
            user_id: 'G' + record.user_id,
            title: record.title,
            with_user_id: 'G' + record.with_user_id,
            object: record.object,
            user_name: record.user_name,
            with_user_name: record.with_user_name
          };
        }
        if (action === 'update') {
          changes.shared_objects['G' + record.id] = {
            title: record.title
          };
        } else if (action === 'delete') {
          if (record.with_user_id) {
            withUserId = parseInt(record.with_user_id);
            if (user.shared) {
              if (user.shared[record.object]) {
                _.pull(user.shared[record.object], withUserId);
                if (!user.shared[record.object].length) {
                  delete user.shared[record.object];
                }
              }
            }
            clientIds = clientsIdsForUserId[withUserId];
            if (clientIds) {
              for (_j = 0, _len1 = clientIds.length; _j < _len1; _j++) {
                clientId = clientIds[_j];
                user.removeSubscriber(clientId, record.object);
              }
            }
          }
          changes.shared_objects['G' + record.id] = 'deleted';
        }
        user.sendUpdate(changes, '*');
      }
      user.done();
      return res.send('ok');
    });
  });
  app.post('/collaborators', function(req, res) {
    var user;
    user = User.user(req.body.userId);
    user.sendUpdate(req.body.changes, '*');
    user.sendUpdate(req.body.changes, req.body.object);
    return res.send('ok');
  });
  app.post('/init', function(req, res) {
    var _name;
    if (clientIdsByServerId[_name = req.body.serverId] == null) {
      clientIdsByServerId[_name] = {};
    }
    clientIdsByServerId[req.body.serverId][req.body.clientId] = true;
    return User.operate(req.body.userId, function(user) {
      return user.hasPermissions(req.body.clientId, 'init', function(permission) {
        if (permission) {
          user.addSubscriber(req.body.clientId, '*');
          return user.data('*', function(data) {
            res.send(data);
            return user.done();
          });
        } else {
          res.send('not allowed');
          return user.done();
        }
      });
    });
  });
  app.post('/update', function(req, res) {
    if (req.body.userId === '0') {
      return request({
        url: "http://" + (getUpdateServer()) + "/update.php?clientId=" + req.body.clientId,
        method: 'post',
        form: {
          updateToken: req.body.updateToken,
          changes: req.body.changes
        }
      }, (function(_this) {
        return function(error, response, body) {
          var e;
          try {
            body = parse(body);
          } catch (_error) {
            e = _error;
            console.log(body);
            throw e;
          }
          return res.send(JSON.stringify({
            updateToken: body.updateToken,
            mapping: body.mapping
          }));
        };
      })(this));
    } else {
      return User.operate(req.body.userId, function(user) {
        return user.hasPermissions(req.body.clientId, 'update', parse(req.body.changes), function(permission) {
          if (permission) {
            return user.update(req.body.clientId, req.body.updateToken, req.body.changes, function(response) {
              res.send(response);
              return user.done();
            });
          } else {
            res.send('not allowed');
            return user.done();
          }
        });
      });
    }
  });
  app.post('/subscribe', function(req, res) {
    var _name;
    if (clientIdsByServerId[_name = req.body.serverId] == null) {
      clientIdsByServerId[_name] = {};
    }
    clientIdsByServerId[req.body.serverId][req.body.clientId] = true;
    return User.operate(req.body.userId, function(user) {
      return user.hasPermissions(req.body.clientId, 'subscribe', req.body.object, function(permission) {
        if (permission) {
          return userIdForClientId(req.body.clientId, function(userId) {
            var _ref;
            if (clientsIdsForUserId[userId] == null) {
              clientsIdsForUserId[userId] = [];
            }
            if (!(_ref = req.body.clientId, __indexOf.call(clientsIdsForUserId[userId], _ref) >= 0)) {
              clientsIdsForUserId[userId].push(req.body.clientId);
            }
            user.addSubscriber(req.body.clientId, req.body.object);
            return user.data(req.body.object, function(data) {
              res.send(data);
              return user.done();
            });
          });
        } else {
          res.send('not allowed');
          return user.done();
        }
      });
    });
  });
  app.post('/unsubscribe', function(req, res) {
    var clientId, object, objects, subscriptions, user, userId, _j, _len1;
    clientId = req.body.clientId;
    if (req.body.userId) {
      user = User.user(req.body.userId);
      user.removeSubscriber(clientId, req.body.object);
    } else if (User.clientSubscriptions[clientId]) {
      subscriptions = _.cloneDeep(User.clientSubscriptions[clientId]);
      for (userId in subscriptions) {
        objects = subscriptions[userId];
        user = User.user(userId);
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          object = objects[_j];
          user.removeSubscriber(clientId, object);
        }
      }
    }
    return res.send('');
  });
  return app.post('/retrieve', function(req, res) {
    return request({
      url: "http://" + (getUpdateServer()) + "/retrieve.php?clientId=" + req.body.clientId,
      method: 'post',
      form: {
        toRetrieve: req.body.records
      }
    }, function(err, response, body) {
      return res.send(body);
    });
  });
};

count = 0;

for (_j = 0, _len1 = portServers.length; _j < _len1; _j++) {
  portServer = portServers[_j];
  request({
    url: 'http://localhost:3001/gateway/started',
    method: 'post',
    form: {
      serverId: serverId
    }
  }, function() {
    if (++count === portServers.length) {
      return start();
    }
  });
}
