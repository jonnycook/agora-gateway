// Generated by CoffeeScript 1.7.1
var Graph, MongoClient, Record, User, app, bodyParser, clientIdsByServerId, clientsIdsForUserId, commands, connection, env, executeCommand, express, graph, graphDef, groupClientIdsByPort, logCommand, mongoDb, mysql, name, parse, processLogsCol, r, rel, rels, request, resolveUserId, serverId, serverProcessId, snapshot, start, table, testLog, userIdForClientId, userIdsByClientId, util, winston, _, _base, _base1, _base2, _i, _len,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

mysql = require('mysql');

_ = require('lodash');

express = require('express');

bodyParser = require('body-parser');

request = require('request');

graph = require('./graph');

require('colors');

require('source-map-support').install();

util = require('util');

testLog = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return console.log.apply(console, ['TEST:'.green].concat(__slice.call(args)));
};

env = null;

if (process.argv[2]) {
  env = require('./env.test');
} else {
  env = require('./env');
}

MongoClient = require('mongodb').MongoClient;

mongoDb = null;

processLogsCol = null;

serverProcessId = new Date().getTime();

if (env.logErrors) {
  winston = require('winston');
  winston.handleExceptions(new winston.transports.File({
    filename: "errors_" + serverProcessId + ".log"
  }));
}

Graph = {
  rels: {},
  root: {},
  inGraph: {},
  fields: {
    root_elements: {
      element_type: 'value'
    },
    bundle_elements: {
      element_type: 'value'
    },
    list_elements: {
      element_type: 'value'
    }
  },
  inGraph: function(table) {
    var _ref;
    return (_ref = this.inGraph[table]) != null ? _ref : this.rels[table];
  },
  children: function(db, table, record) {
    var contained, containedRecord, containedTable, records, rel, _i, _j, _len, _len1, _ref, _ref1;
    contained = [];
    _ref = this.rels[table];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rel = _ref[_i];
      if (rel.owns) {
        if (!rel.foreignKey) {
          containedTable = _.isFunction(rel.table) ? rel.table(record) : rel.table;
          containedRecord = (_ref1 = db[containedTable]) != null ? _ref1[record[rel.field]] : void 0;
          if (containedRecord) {
            if (_.isFunction(rel.owns)) {
              if (rel.owns(containedRecord)) {
                contained.push({
                  table: containedTable,
                  record: containedRecord
                });
              }
            } else {
              contained.push({
                table: containedTable,
                record: containedRecord
              });
            }
          }
        } else {
          records = _.filter(db[rel.table], function(r) {
            return r[rel.field] === record.id;
          });
          for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
            record = records[_j];
            contained.push({
              table: rel.table,
              record: record
            });
          }
        }
      }
    }
    return contained;
  },
  contained: function(db, table, record) {
    var contained, containedRecord, containedTable, records, rel, _i, _j, _len, _len1, _ref, _ref1;
    contained = [];
    _ref = this.rels[table];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rel = _ref[_i];
      if (rel.owns) {
        if (!rel.foreignKey) {
          containedTable = _.isFunction(rel.table) ? rel.table(record) : rel.table;
          containedRecord = (_ref1 = db[containedTable]) != null ? _ref1[record[rel.field]] : void 0;
          if (containedRecord) {
            if (_.isFunction(rel.owns)) {
              if (rel.owns(containedRecord)) {
                contained.push({
                  table: containedTable,
                  record: containedRecord
                });
                contained = contained.concat(this.contained(db, containedTable, containedRecord));
              }
            } else {
              contained.push({
                table: containedTable,
                record: containedRecord
              });
              contained = contained.concat(this.contained(db, containedTable, containedRecord));
            }
          }
        } else {
          records = _.filter(db[rel.table], function(r) {
            return r[rel.field] === record.id;
          });
          for (_j = 0, _len1 = records.length; _j < _len1; _j++) {
            record = records[_j];
            contained.push({
              table: rel.table,
              record: record
            });
            contained = contained.concat(this.contained(db, rel.table, record));
          }
        }
      }
    }
    return contained;
  },
  owner: function(db, table, record) {
    var ownerRecord, records, rel, _i, _len, _ref;
    if (this.root[table]) {
      return null;
    } else if (this.rels[table]) {
      _ref = this.rels[table];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rel = _ref[_i];
        if (rel.owner) {
          if (!rel.foreignKey) {
            table = _.isFunction(rel.table) ? rel.table(this) : rel.table;
            if (!db[table]) {
              console.log(table);
            }
            ownerRecord = db[table][record[rel.field]];
            if (ownerRecord) {
              return {
                table: table,
                record: ownerRecord
              };
            }
          } else {
            if (rel.filter) {
              records = _.filter(db[rel.table], function(r) {
                return r[rel.field] === record.id && rel.filter(table, record, r);
              });
            } else {
              records = _.filter(db[rel.table], function(r) {
                return r[rel.field] === record.id;
              });
            }
            if (records[0]) {
              return {
                table: rel.table,
                record: records[0]
              };
            }
          }
        }
      }
    }
  }
};

Graph.fieldRel = {};

for (table in graph) {
  graphDef = graph[table];
  Graph.rels[table] = rels = [];
  for (name in graphDef) {
    rel = graphDef[name];
    if (name === 'root') {
      Graph.root[table] = rel;
    } else if (name === 'inGraph') {
      Graph.inGraph[table] = rel;
    } else {
      if (!_.isArray(rel)) {
        rel = [rel];
      }
      for (_i = 0, _len = rel.length; _i < _len; _i++) {
        r = rel[_i];
        if (r.table) {
          if ((_base = Graph.fieldRel)[table] == null) {
            _base[table] = {};
          }
          Graph.fieldRel[table][name] = r;
          if (!_.isFunction(r.table)) {
            if ((_base1 = Graph.fields)[table] == null) {
              _base1[table] = {};
            }
            Graph.fields[table][name] = 'id';
          }
          rels.push({
            table: r.table,
            owns: r.owns,
            owner: r.owner,
            field: name,
            filter: r.filter
          });
        } else if (r.field) {
          if ((_base2 = Graph.fields)[name] == null) {
            _base2[name] = {};
          }
          Graph.fields[name][r.field] = 'id';
          rels.push({
            foreignKey: true,
            field: r.field,
            table: name,
            owns: r.owns,
            owner: r.owner,
            filter: r.filter
          });
        }
      }
    }
  }
}

Record = (function() {
  function Record(table, fields) {
    this.table = table;
    this.fields = fields;
  }

  Record.prototype.forEachRelationship = function(cb) {
    var count, record, records, tick, _fn, _j, _len1;
    table = this.table;
    record = this.fields;
    rels = Graph.rels[table];
    records = [];
    if (rels.length) {
      count = 0;
      tick = function() {
        if (!--count) {
          return cb();
        }
      };
      _fn = (function(_this) {
        return function(rel) {
          var owns;
          if (rel.owns) {
            owns = _.isFunction(rel.owns) ? rel.owns(_this.fields) : rel.owns;
            if (owns) {
              ++count;
              if (rel.foreignKey) {
                table = rel.table;
                return (function(table) {
                  return connection.query("SELECT * FROM m_" + table + " WHERE " + rel.field + " = " + record.id, function(err, rows, fields) {
                    var row, _k, _len2;
                    for (_k = 0, _len2 = rows.length; _k < _len2; _k++) {
                      row = rows[_k];
                      cb(new Record(table, row));
                    }
                    return tick();
                  });
                })(table);
              } else {
                table = _.isFunction(rel.table) ? rel.table(record) : rel.table;
                return (function(table) {
                  return connection.query("SELECT * FROM m_" + table + " WHERE id = " + record[rel.field], function(err, rows, fields) {
                    cb(new Record(table, rows[0]));
                    return tick();
                  });
                })(table);
              }
            }
          }
        };
      })(this);
      for (_j = 0, _len1 = rels.length; _j < _len1; _j++) {
        rel = rels[_j];
        _fn(rel);
      }
      if (!count) {
        return cb();
      }
    } else {
      return cb();
    }
  };

  Record.prototype.getRelationships = function(cb) {
    var records;
    records = [];
    return this.forEachRelationship(function(record) {
      if (record) {
        return records.push(record);
      } else {
        return cb(records);
      }
    });
  };

  Record.prototype.contained = function(cb) {
    var count, done, records, sent;
    records = [];
    count = 0;
    sent = false;
    done = false;
    return this.forEachRelationship(function(record) {
      if (record) {
        ++count;
        records.push(record);
        return record.contained(function(r) {
          records = records.concat(r);
          --count;
          if (!count && done) {
            sent = true;
            return cb(records);
          }
        });
      } else {
        done = true;
        if (!count && !sent) {
          return cb(records);
        }
      }
    });
  };

  return Record;

})();

logCommand = function(type, params) {
  var timestamp;
  if (env.log) {
    timestamp = new Date().getTime();
    return processLogsCol.insert({
      timestamp: timestamp,
      type: type,
      params: JSON.stringify(params)
    }, function() {});
  }
};

clientIdsByServerId = {};

clientsIdsForUserId = {};

userIdsByClientId = {};

userIdForClientId = function(clientId, cb) {
  if (userIdsByClientId[clientId]) {
    return cb(userIdsByClientId[clientId]);
  } else {
    return connection.query("SELECT user_id FROM clients WHERE client_id = '" + clientId + "'", function(error, rows, fields) {
      var data;
      userIdsByClientId[clientId] = parseInt(rows[0].user_id);
      data = {};
      data["clients." + clientId] = userIdsByClientId[clientId];
      mongoDb.collection('snapshots').update({
        _id: serverProcessId
      }, {
        '$set': data
      }, function() {});
      return cb(userIdsByClientId[clientId]);
    });
  }
};

parse = function(json, cbs) {
  var e, obj;
  if (cbs == null) {
    cbs = null;
  }
  if (cbs) {
    obj = null;
    try {
      obj = JSON.parse(json);
    } catch (_error) {
      e = _error;
      cbs.error(json);
    }
    if (obj) {
      return cbs.success(obj);
    }
  } else {
    return JSON.parse(json);
  }
};

User = (function() {
  User.users = {};

  User.user = function(userId) {
    var _base3;
    return (_base3 = this.users)[userId] != null ? _base3[userId] : _base3[userId] = new User(userId);
  };

  User.userByClientId = function(clientId, cb) {
    return userIdForClientId(clientId, (function(_this) {
      return function(userId) {
        return cb(_this.user(userId));
      };
    })(this));
  };

  User.operateByClientId = function(clientId, cb) {
    return this.userByClientId(clientId, function(user) {
      return user.operate(function() {
        return cb(user);
      });
    });
  };

  User.operate = function(userId, cb) {
    var user;
    user = this.user(userId);
    return user.operate(function() {
      return cb(user);
    });
  };

  User.clientSubscriptions = {};

  function User(id) {
    this.id = parseInt(id);
    this.clientIds = {};
  }

  User.prototype.operate = function(cb) {
    if (this.operating) {
      if (this.queue == null) {
        this.queue = [];
      }
      return this.queue.push(cb);
    } else {
      this.operating = true;
      return cb();
    }
  };

  User.prototype.done = function() {
    var func;
    this.operating = false;
    if (this.queue) {
      func = this.queue.shift();
      if (!this.queue.length) {
        delete this.queue;
      }
      return func();
    }
  };

  User.prototype.sendUpdate = function(changes, object) {
    var clientIds, grouped, port, subscribers, _ref, _results;
    subscribers = (_ref = this.subscribers) != null ? _ref[object] : void 0;
    if (subscribers) {
      grouped = groupClientIdsByPort(subscribers);
      if (_.isObject(changes)) {
        changes = JSON.stringify(changes);
      }
      _results = [];
      for (port in grouped) {
        clientIds = grouped[port];
        if (!env.test) {
          _results.push(request({
            url: "http://" + port + "/update",
            method: 'post',
            form: {
              clientIds: clientIds,
              userId: this.id,
              changes: changes
            }
          }));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  User.prototype.deleteFromOutline = function(table, id) {
    testLog('deleteFromOutline', table, id);
    return delete this.outline[table][id];
  };

  User.prototype.update = function(clientId, updateToken, changes, cb) {
    return this.initOutline((function(_this) {
      return function() {
        return request({
          url: "http://" + (env.getUpdateServer()) + "/update.php?clientId=" + clientId + "&userId=" + _this.id,
          method: 'post',
          form: {
            updateToken: updateToken,
            changes: changes
          }
        }, function(error, response, body) {
          if (body === 'invalid update token') {
            return cb('invalid client id');
          } else if (body === 'invalid client id') {
            return cb('invalid client id');
          } else {
            return parse(body, {
              error: function(error) {
                console.log('error', error);
                return cb('error');
              },
              success: function(body) {
                var add, addChangesForSubscribers, broadcast, changesForSubscribers, child, children, contained, count, field, fields, id, ids, newId, recordChanges, relTable, t, tableChanges, toDelete, value, __, _base3, _j, _k, _len1, _len2, _name, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
                if (body.status === 'ok') {
                  if (_this.subscribers && body.changes) {
                    delete body.changes.products;
                    delete body.changes.product_variants;
                    changesForSubscribers = {};
                    if (_this.subscribers['*']) {
                      changesForSubscribers['*'] = body.changes;
                    }
                    if (_this.subscribers['/']) {
                      changesForSubscribers['/'] = body.changes;
                    }
                    if (_this.subscribers['@'] && ((_ref = body.changes) != null ? (_ref1 = _ref.users) != null ? _ref1["G" + _this.id] : void 0 : void 0)) {
                      id = "G" + _this.id;
                      changes = {
                        users: {}
                      };
                      changes.users[id] = body.changes.users[id];
                      changesForSubscribers['@'] = changes;
                    }
                    broadcast = function() {
                      var clientIds, grouped, object, port, subscribers;
                      if (env.test) {

                      } else {
                        for (object in changesForSubscribers) {
                          changes = changesForSubscribers[object];
                          subscribers = _.without(_this.subscribers[object], clientId);
                          if (subscribers.length) {
                            grouped = groupClientIdsByPort(subscribers);
                            changes = JSON.stringify(body.changes);
                            for (port in grouped) {
                              clientIds = grouped[port];
                              request({
                                url: "http://" + port + "/update",
                                method: 'post',
                                form: {
                                  clientIds: clientIds,
                                  userId: _this.id,
                                  changes: changes
                                }
                              });
                            }
                          }
                        }
                      }
                      return cb(JSON.stringify({
                        status: 'ok',
                        updateToken: body.updateToken,
                        mapping: body.mapping
                      }));
                    };
                    if (_this.outline) {
                      addChangesForSubscribers = function(object, table, id, changes) {
                        var _base3;
                        if (_this.subscribers[object]) {
                          if (changesForSubscribers[object] == null) {
                            changesForSubscribers[object] = {};
                          }
                          if ((_base3 = changesForSubscribers[object])[table] == null) {
                            _base3[table] = {};
                          }
                          if (!changesForSubscribers[object][table][id]) {
                            return changesForSubscribers[object][table][id] = changes;
                          } else {
                            return _.extend(changesForSubscribers[object][table][id], changes);
                          }
                        }
                      };
                      add = function(table, id, changes) {
                        var _ref2, _results;
                        if (table !== 'activity' && !((_ref2 = _this.outline[table]) != null ? _ref2[id] : void 0)) {
                          console.log('missing %s.%s', table, id);
                          return;
                        }
                        r = table === 'activity' ? Graph.owner(_this.outline, table, changes) : {
                          table: table,
                          record: _this.outline[table][id]
                        };
                        _results = [];
                        while (r) {
                          addChangesForSubscribers("" + r.table + "." + r.record.id, table, 'G' + id, changes);
                          _results.push(r = Graph.owner(_this.outline, r.table, r.record));
                        }
                        return _results;
                      };
                      _ref2 = body.changes;
                      for (table in _ref2) {
                        tableChanges = _ref2[table];
                        if (Graph.inGraph(table)) {
                          for (id in tableChanges) {
                            recordChanges = tableChanges[id];
                            if (recordChanges !== 'deleted') {
                              id = parseInt(id.substr(1));
                              _this.addToOutline(table, id, recordChanges);
                            }
                          }
                        }
                      }
                      _ref3 = body.changes;
                      for (table in _ref3) {
                        tableChanges = _ref3[table];
                        if (Graph.inGraph(table)) {
                          for (id in tableChanges) {
                            recordChanges = tableChanges[id];
                            add(table, parseInt(id.substr(1)), recordChanges);
                          }
                        }
                      }
                      count = 0;
                      toDelete = {};
                      _ref4 = body.changes;
                      for (table in _ref4) {
                        tableChanges = _ref4[table];
                        if (table === 'activity') {
                          continue;
                        }
                        if (Graph.inGraph(table)) {
                          if ((_base3 = _this.outline)[table] == null) {
                            _base3[table] = {};
                          }
                          for (id in tableChanges) {
                            recordChanges = tableChanges[id];
                            id = parseInt(id.substr(1));
                            if (!((_ref5 = _this.outline[table]) != null ? _ref5[id] : void 0)) {
                              console.log('missing %s.%s', table, id);
                              continue;
                            }
                            if (recordChanges === 'deleted') {
                              children = Graph.children(_this.outline, table, _this.outline[table][id]);
                              for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
                                child = children[_j];
                                if (toDelete[_name = child.table] == null) {
                                  toDelete[_name] = {};
                                }
                                toDelete[child.table][child.record.id] = true;
                              }
                              _this.deleteFromOutline(table, id);
                            } else {
                              fields = Graph.fields[table];
                              if (fields) {
                                for (field in fields) {
                                  if (Graph.fields[table][field] === 'id' && (value = recordChanges[field])) {
                                    newId = parseInt(value.substr(1));
                                    if (r = (_ref6 = Graph.fieldRel) != null ? (_ref7 = _ref6[table]) != null ? _ref7[field] : void 0 : void 0) {
                                      t = r.table;
                                      relTable = _.isFunction(t) ? t(_this.outline[table][id]) : t;
                                      if (Graph.inGraph(relTable)) {
                                        if (!((_ref8 = _this.outline[relTable]) != null ? _ref8[newId] : void 0)) {
                                          ++count;
                                          (function(table, id) {
                                            return _this.data("" + relTable + "." + newId, (function(data) {
                                              return parse(data, {
                                                error: function(error) {
                                                  console.log(error);
                                                  return cb('error');
                                                },
                                                success: function(data) {
                                                  var dataId, dataRecord, dataRecords, dataTable;
                                                  _.merge(changesForSubscribers['*'], data);
                                                  _.merge(changesForSubscribers['/'], data);
                                                  for (dataTable in data) {
                                                    dataRecords = data[dataTable];
                                                    for (dataId in dataRecords) {
                                                      dataRecord = dataRecords[dataId];
                                                      dataId = parseInt(dataId.substr(1));
                                                      _this.addToOutline(dataTable, dataId, dataRecord);
                                                      add(dataTable, dataId, dataRecord);
                                                    }
                                                  }
                                                  if (!--count) {
                                                    return broadcast();
                                                  }
                                                }
                                              });
                                            }), {
                                              claim: true,
                                              collaborators: false
                                            });
                                          })(table, id);
                                        } else {
                                          if ((_ref9 = toDelete[relTable]) != null ? _ref9[newId] : void 0) {
                                            delete toDelete[relTable][newId];
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      for (table in toDelete) {
                        ids = toDelete[table];
                        for (id in ids) {
                          __ = ids[id];
                          contained = Graph.contained(_this.outline, table, _this.outline[table][id]);
                          for (_k = 0, _len2 = contained.length; _k < _len2; _k++) {
                            r = contained[_k];
                            _this.deleteFromOutline(r.table, r.record.id);
                          }
                          _this.deleteFromOutline(table, id);
                        }
                      }
                      if (!count) {
                        return broadcast();
                      }
                    } else {
                      return broadcast();
                    }
                  } else {
                    return cb(JSON.stringify({
                      status: 'ok',
                      updateToken: body.updateToken,
                      mapping: body.mapping
                    }));
                  }
                } else if (body.status === 'invalidUpdateToken') {
                  return cb(JSON.stringify({
                    status: 'invalidUpdateToken',
                    updateToken: body.updateToken
                  }));
                }
              }
            });
          }
        });
      };
    })(this));
  };

  User.prototype.addSubscriber = function(clientId, object) {
    var _base3, _base4, _base5, _name;
    if (!(object === '*' || object === '/' || object === '@')) {
      this.needsOutline = true;
    }
    if (this.subscribers == null) {
      this.subscribers = {};
    }
    if ((_base3 = this.subscribers)[object] == null) {
      _base3[object] = [];
    }
    if (!(__indexOf.call(this.subscribers[object], clientId) >= 0)) {
      this.subscribers[object].push(clientId);
      if ((_base4 = User.clientSubscriptions)[clientId] == null) {
        _base4[clientId] = {};
      }
      if ((_base5 = User.clientSubscriptions[clientId])[_name = this.id] == null) {
        _base5[_name] = [];
      }
      return User.clientSubscriptions[clientId][this.id].push(object);
    }
  };

  User.prototype.removeSubscriber = function(clientId, object) {
    var count, o, size, _j, _len1, _ref, _ref1;
    if (this.subscribers[object]) {
      _.pull(this.subscribers[object], clientId);
      if (!this.subscribers[object].length) {
        delete this.subscribers[object];
        if (_.isEmpty(this.subscribers)) {
          delete this.subscribers;
          delete this.outline;
        } else if (this.outline) {
          size = _.size(this.subscribers);
          if (size <= 3) {
            count = 0;
            _ref = ['*', '/', '@'];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              o = _ref[_j];
              if (this.subscribers[o]) {
                count++;
              }
            }
            if (count === size) {
              delete this.outline;
            }
          }
        }
      }
    }
    if ((_ref1 = User.clientSubscriptions[clientId]) != null ? _ref1[this.id] : void 0) {
      _.pull(User.clientSubscriptions[clientId][this.id], object);
      if (!User.clientSubscriptions[clientId][this.id].length) {
        delete User.clientSubscriptions[clientId][this.id];
        if (_.isEmpty(User.clientSubscriptions[clientId])) {
          return delete User.clientSubscriptions[clientId];
        }
      }
    }
  };

  User.prototype.hasPermissions = function() {
    var action, args, cb, clientId, _j;
    clientId = arguments[0], action = arguments[1], args = 4 <= arguments.length ? __slice.call(arguments, 2, _j = arguments.length - 1) : (_j = 2, []), cb = arguments[_j++];
    if (clientId === 'Carl Sagan') {
      return cb(true);
    } else {
      return userIdForClientId(clientId, (function(_this) {
        return function(userId) {
          var object;
          if (action === 'init') {
            if (userId === _this.id) {
              return cb(true);
            } else {
              return cb(false);
            }
          } else if (action === 'update') {
            if (userId === _this.id) {
              return cb(true);
            } else {
              return _this.initShared(function() {
                return _this.initOutline((function() {
                  var changes, id, object, permitted, recordChanges, tableChanges, _ref, _ref1;
                  changes = args[0];
                  if (_this.shared['/'] && __indexOf.call(_this.shared['/'], userId) >= 0) {
                    for (table in changes) {
                      tableChanges = changes[table];
                      for (id in tableChanges) {
                        recordChanges = tableChanges[id];
                        if (id[0] === 'G' && !((_ref = _this.outline) != null ? (_ref1 = _ref[table]) != null ? _ref1[id.substr(1)] : void 0 : void 0)) {
                          cb(false);
                          return;
                        }
                      }
                    }
                  } else {
                    for (table in changes) {
                      tableChanges = changes[table];
                      for (id in tableChanges) {
                        recordChanges = tableChanges[id];
                        if (id[0] === 'G') {
                          id = id.substr(1);
                          if (_this.outline[table][id]) {
                            r = {
                              table: table,
                              record: _this.outline[table][id]
                            };
                            permitted = false;
                            while (r) {
                              object = "" + r.table + "." + r.record.id;
                              if (_this.shared[object] && (__indexOf.call(_this.shared[object], userId) >= 0)) {
                                permitted = true;
                                break;
                              }
                              r = Graph.owner(_this.outline, r.table, r.record);
                            }
                            if (!permitted) {
                              cb(false);
                              return;
                            }
                          } else {
                            cb(false);
                            return;
                          }
                        }
                      }
                    }
                  }
                  return cb(true);
                }), true);
              });
            }
          } else if (action === 'subscribe') {
            object = args[0];
            if (userId === _this.id) {
              if (object === '*') {
                return cb(true);
              } else {
                return cb(false);
              }
            } else {
              if (object === '@') {
                return connection.query("SELECT 1 FROM shared WHERE user_id = " + userId + " && with_user_id = " + _this.id + " || user_id = " + _this.id + " && with_user_id = " + userId, function(err, rows) {
                  var key, uId, _ref;
                  if (rows.length) {
                    return cb(true);
                  } else if (args[1]) {
                    key = args[1];
                    _ref = key.split(' '), uId = _ref[0], object = _ref[1];
                    return connection.query("SELECT COUNT(*) c FROM shared WHERE user_id = " + uId + " && object = '" + object + "' && with_user_id IN (" + userId + ", " + _this.id + ")", function(err, rows) {
                      return cb(rows[0].c === 2);
                    });
                  } else {
                    return cb(false);
                  }
                });
              } else {
                return _this.initShared(function() {
                  if (_this.shared[object] && (__indexOf.call(_this.shared[object], userId) >= 0)) {
                    return cb(true);
                  } else {
                    return cb(false);
                  }
                });
              }
            }
          }
        };
      })(this));
    }
  };

  User.prototype.initShared = function(cb) {
    if (!this.shared) {
      this.shared = {};
      return connection.query("SELECT * FROM shared WHERE user_id = " + this.id, (function(_this) {
        return function(error, rows, fields) {
          var row, _base3, _j, _len1, _name;
          for (_j = 0, _len1 = rows.length; _j < _len1; _j++) {
            row = rows[_j];
            if ((_base3 = _this.shared)[_name = row.object] == null) {
              _base3[_name] = [];
            }
            _this.shared[row.object].push(row.with_user_id);
          }
          return cb();
        };
      })(this));
    } else {
      return cb();
    }
  };

  User.prototype.data = function(object, cb, opts) {
    if (opts == null) {
      opts = {};
    }
    if (opts.claim == null) {
      opts.claim = false;
    }
    if (opts.collaborators == null) {
      opts.collaborators = true;
    }
    return request({
      url: "http://" + (env.getUpdateServer()) + "/data.php?userId=" + this.id + "&object=" + object + "&claim=" + (opts.claim ? 1 : 0) + "&collaborators=" + (opts.collaborators ? 1 : 0)
    }, function(err, response, body) {
      return cb(body);
    });
  };

  User.prototype.addToOutline = function(table, id, inValues) {
    var contained, field, type, value, values, _base3, _j, _len1, _ref;
    testLog(this.id, 'addToOutline', table, id, inValues);
    if (table === 'activity') {
      return;
    }
    values = {};
    _ref = Graph.fields[table];
    for (name in _ref) {
      type = _ref[name];
      if (name in inValues) {
        if (type === 'value') {
          values[name] = inValues[name];
        } else if (type === 'id') {
          if (inValues[name][0] === 'G') {
            values[name] = parseInt(inValues[name].substr(1));
          } else {
            values[name] = parseInt(inValues[name]);
          }
        }
      }
    }
    if ((_base3 = this.outline)[table] == null) {
      _base3[table] = {};
    }
    if (!this.outline[table][id]) {
      values.id = parseInt(id);
      return this.outline[table][id] = values;
    } else {
      for (field in values) {
        value = values[field];
        if (Graph.fields[table][field] === 'id' && value !== this.outline[table][id][field]) {
          contained = Graph.contained(this.outline, table, this.outline[table][id]);
          for (_j = 0, _len1 = contained.length; _j < _len1; _j++) {
            r = contained[_j];
            this.deleteFromOutline(r.table, r.record.id);
          }
          break;
        }
      }
      return _.extend(this.outline[table][id], values);
    }
  };

  User.prototype.addRecord = function(record) {
    return this.addToOutline(record.table, record.fields.id, record.fields);
  };

  User.prototype.initOutline = function(cb, force) {
    if (force == null) {
      force = false;
    }
    if (!this.outline && (this.needsOutline || force)) {
      this.outline = {};
      delete this.needsOutline;
      return connection.query("SELECT * FROM m_root_elements WHERE user_id = " + this.id, (function(_this) {
        return function(err, rows, fields) {
          var count, record, row, _j, _len1, _results;
          if (rows.length) {
            count = rows.length;
            _results = [];
            for (_j = 0, _len1 = rows.length; _j < _len1; _j++) {
              row = rows[_j];
              record = new Record('root_elements', row);
              _this.addRecord(record);
              _results.push(record.contained(function(records) {
                var _k, _len2;
                for (_k = 0, _len2 = records.length; _k < _len2; _k++) {
                  record = records[_k];
                  _this.addRecord(record);
                }
                --count;
                if (!count) {
                  return cb();
                }
              }));
            }
            return _results;
          } else {
            return cb();
          }
        };
      })(this));
    } else {
      return cb();
    }
  };

  return User;

})();

connection = mysql.createConnection(env.db);

connection.connect();

app = express();

app.use(bodyParser());

app.listen(env.httpPort);

groupClientIdsByPort = function(clientIds) {
  var clientId, grouped, port, _j, _len1;
  grouped = {};
  for (_j = 0, _len1 = clientIds.length; _j < _len1; _j++) {
    clientId = clientIds[_j];
    port = env.portForClient(clientId);
    if (grouped[port] == null) {
      grouped[port] = [];
    }
    grouped[port].push(clientId);
  }
  return grouped;
};

app.get('/debug', function(req, res) {
  var user, userId;
  console.log('====DEBUG====');
  userId = req.query.userId;
  user = User.user(userId);
  console.log('=user.subscribers=');
  console.log(user.subscribers);
  console.log('=user.outline=');
  console.log(user.outline);
  console.log('=user.shared=');
  console.log(user.shared);
  console.log('=User.clientSubscriptions=');
  console.log(User.clientSubscriptions);
  console.log('=clientIdsByServerId=');
  console.log(clientIdsByServerId);
  return res.send('');
});

serverId = 1;

resolveUserId = function(user, params, cb) {
  if (params.clientId === 'Carl Sagan') {
    return cb(params.userId);
  } else {
    return userIdForClientId(params.clientId, function(userId) {
      if (userId === parseInt(params.userId)) {
        return cb(userId);
      } else {
        return cb(null);
      }
    });
  }
};

commands = {
  init: function(user, params, sendResponse) {
    var _name;
    if (clientIdsByServerId[_name = params.serverId] == null) {
      clientIdsByServerId[_name] = {};
    }
    clientIdsByServerId[params.serverId][params.clientId] = true;
    return user.hasPermissions(params.clientId, 'init', function(permission) {
      if (permission) {
        user.addSubscriber(params.clientId, '*');
        return user.data('*', function(data) {
          return sendResponse(data);
        });
      } else {
        return sendResponse('not allowed');
      }
    });
  },
  'share/create': function(user, params, sendResponse) {
    resolveUserId(user, params, function(userId) {
      if (userId) {
        return request({
          url: "http://" + (env.getUpdateServer()) + "/shared/create.php?userId=" + userId,
          method: 'post',
          form: params
        }, function(err, response, body) {
          return console.log(body);
        });
      }
    });
    return sendResponse();
  },
  'share/delete': function(user, params, sendResponse) {
    resolveUserId(user, params, function(userId) {
      console.log('hahah', userId);
      if (userId) {
        return request({
          url: "http://" + (env.getUpdateServer()) + "/shared/delete.php?userId=" + userId,
          method: 'post',
          form: params
        });
      }
    });
    return sendResponse();
  },
  'share/update': function(user, params, sendResponse) {
    resolveUserId(user, params, function(userId) {
      if (userId) {
        return request({
          url: "http://" + (env.getUpdateServer()) + "/shared/update.php?userId=" + userId,
          method: 'post',
          form: params
        });
      }
    });
    return sendResponse();
  },
  shared: function(user, params, sendResponse) {
    var action, changes, clientId, clientIds, record, withUserId, _j, _len1, _ref;
    record = params.record;
    action = params.action;
    if ((_ref = user.subscribers) != null ? _ref['*'] : void 0) {
      changes = {
        shared_objects: {}
      };
      if (action === 'create') {
        if (user.shared && parseInt(record.user_id) === user.id) {
          if (!user.shared[record.object]) {
            user.shared[record.object] = [];
          }
          user.shared[record.object].push(parseInt(record.with_user_id));
        }
        changes.shared_objects['G' + record.id] = {
          user_id: 'G' + record.user_id,
          title: record.title,
          with_user_id: 'G' + record.with_user_id,
          object: record.object,
          user_name: record.user_name,
          with_user_name: record.with_user_name
        };
      }
      if (action === 'update') {
        changes.shared_objects['G' + record.id] = {
          title: record.title
        };
      } else if (action === 'delete') {
        if (record.with_user_id) {
          withUserId = parseInt(record.with_user_id);
          if (user.shared) {
            if (user.shared[record.object]) {
              _.pull(user.shared[record.object], withUserId);
              if (!user.shared[record.object].length) {
                delete user.shared[record.object];
              }
            }
          }
          clientIds = clientsIdsForUserId[withUserId];
          if (clientIds) {
            for (_j = 0, _len1 = clientIds.length; _j < _len1; _j++) {
              clientId = clientIds[_j];
              user.removeSubscriber(clientId, record.object);
            }
          }
        }
        changes.shared_objects['G' + record.id] = 'deleted';
      }
      user.sendUpdate(changes, '*');
    }
    return sendResponse('ok');
  },
  collaborators: function(user, params, sendResponse) {
    user.sendUpdate(params.changes, '*');
    user.sendUpdate(params.changes, params.object);
    return sendResponse('ok');
  },
  update: function(user, params, sendResponse) {
    return user.hasPermissions(params.clientId, 'update', parse(params.changes), function(permission) {
      if (permission) {
        return user.update(params.clientId, params.updateToken, params.changes, function(response) {
          return sendResponse(response);
        });
      } else {
        return sendResponse('not allowed');
      }
    });
  },
  subscribe: function(user, params, sendResponse) {
    var _name;
    if (clientIdsByServerId[_name = params.serverId] == null) {
      clientIdsByServerId[_name] = {};
    }
    clientIdsByServerId[params.serverId][params.clientId] = true;
    return user.hasPermissions(params.clientId, 'subscribe', params.object, params.key, function(permission) {
      if (permission) {
        return userIdForClientId(params.clientId, function(userId) {
          var _ref;
          if (clientsIdsForUserId[userId] == null) {
            clientsIdsForUserId[userId] = [];
          }
          if (!(_ref = params.clientId, __indexOf.call(clientsIdsForUserId[userId], _ref) >= 0)) {
            clientsIdsForUserId[userId].push(params.clientId);
          }
          user.addSubscriber(params.clientId, params.object);
          return user.data(params.object, function(data) {
            return sendResponse(data);
          });
        });
      } else {
        return sendResponse('not allowed');
      }
    });
  },
  unsubscribe: function(user, params, sendResponse) {
    var clientId;
    clientId = params.clientId;
    user.removeSubscriber(clientId, params.object);
    return sendResponse('');
  },
  unsubscribeClient: function(params, sendResponse) {
    var clientId, object, objects, subscriptions, user, userId, _j, _len1;
    clientId = params.clientId;
    if (User.clientSubscriptions[clientId]) {
      subscriptions = _.cloneDeep(User.clientSubscriptions[clientId]);
      for (userId in subscriptions) {
        objects = subscriptions[userId];
        user = User.user(userId);
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          object = objects[_j];
          user.removeSubscriber(clientId, object);
        }
      }
    }
    return sendResponse('');
  },
  retrieve: function(params, sendResponse) {
    return request({
      url: "http://" + (env.getUpdateServer()) + "/retrieve.php?clientId=" + params.clientId,
      method: 'post',
      form: {
        toRetrieve: params.records
      }
    }, function(err, response, body) {
      return sendResponse(body);
    });
  }
};

executeCommand = function(type, params, sendResponse) {
  console.log('command', type, params);
  logCommand(type, params);
  if (params.userId && commands[type].length === 3) {
    return User.operate(params.userId, function(user) {
      return commands[type](user, params, function(response) {
        sendResponse(response);
        return user.done();
      });
    });
  } else {
    return commands[type](params, sendResponse);
  }
};

start = function() {
  var commandName, __, _fn;
  console.log('started');
  _fn = function(commandName) {
    return app.post("/" + commandName, function(req, res) {
      return executeCommand(commandName, req.body, function(response) {
        return res.send(response);
      });
    });
  };
  for (commandName in commands) {
    __ = commands[commandName];
    _fn(commandName);
  }
  return app.post('/port/started', function(req, res) {
    var clientId, clientIds, object, objects, subscriptions, user, userId, _j, _len1;
    if (clientIdsByServerId[req.body.serverId]) {
      clientIds = clientIdsByServerId[req.body.serverId];
      for (clientId in clientIds) {
        __ = clientIds[clientId];
        subscriptions = _.cloneDeep(User.clientSubscriptions[clientId]);
        for (userId in subscriptions) {
          objects = subscriptions[userId];
          user = User.user(userId);
          for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
            object = objects[_j];
            user.removeSubscriber(clientId, object);
          }
        }
      }
      delete clientIdsByServerId[req.body.serverId];
    }
    return res.send('ok');
  });
};

if (process.argv[2]) {
  snapshot = process.argv[2];
  start();
  request({
    url: "http://" + (env.getUpdateServer()) + "/restoreSnapshot.php?id=" + snapshot,
    method: 'get'
  }, function() {
    return MongoClient.connect(env.mongoDb, function(err, db) {
      var cursor;
      mongoDb = db;
      processLogsCol = mongoDb.collection("processLogs_" + snapshot);
      cursor = processLogsCol.find();
      return cursor.toArray(function(err, docs) {
        var current, next;
        current = 0;
        next = function() {
          var doc, params, type;
          if (current < docs.length) {
            doc = docs[current++];
            params = JSON.parse(doc.params);
            type = doc.type;
            console.log('>', type, params);
            if (params.userId && commands[type].length === 3) {
              return User.operate(params.userId, function(user) {
                return commands[type](user, params, function(response) {
                  console.log('< %s'.blue, response);
                  user.done();
                  return next();
                });
              });
            } else {
              return commands[type](params, function(response) {
                console.log('< %s'.blue, response);
                return next();
              });
            }
          } else {
            return console.log('done');
          }
        };
        return next();
      });
    });
  });
} else {
  request({
    method: 'get',
    url: "http://" + (env.getUpdateServer()) + "/saveSnapshot.php?id=" + serverProcessId
  }, (function(_this) {
    return function(error, response, body) {
      return env.init(function() {
        return MongoClient.connect(env.mongoDb, function(err, db) {
          var count, portServer, _j, _len1, _ref, _results;
          mongoDb = db;
          processLogsCol = mongoDb.collection("processLogs_" + serverProcessId);
          count = 0;
          _ref = env.portServers;
          _results = [];
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            portServer = _ref[_j];
            _results.push(request({
              url: "http://" + portServer + "/gateway/started",
              method: 'post',
              form: {
                serverId: serverId
              }
            }, function(error) {
              if (error) {
                console.log('has error', error);
              }
              if (++count === env.portServers.length) {
                return start();
              }
            }));
          }
          return _results;
        });
      });
    };
  })(this));
}

//# sourceMappingURL=server.map
